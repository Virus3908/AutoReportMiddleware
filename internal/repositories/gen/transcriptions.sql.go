// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: transcriptions.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createTranscriptionWithTaskAndSegmentID = `-- name: CreateTranscriptionWithTaskAndSegmentID :exec
INSERT INTO transcriptions (task_id, segment_id) VALUES ($1, $2)
`

type CreateTranscriptionWithTaskAndSegmentIDParams struct {
	TaskID    uuid.UUID `json:"task_id"`
	SegmentID uuid.UUID `json:"segment_id"`
}

func (q *Queries) CreateTranscriptionWithTaskAndSegmentID(ctx context.Context, arg CreateTranscriptionWithTaskAndSegmentIDParams) error {
	_, err := q.db.Exec(ctx, createTranscriptionWithTaskAndSegmentID, arg.TaskID, arg.SegmentID)
	return err
}

const getCountOfUntranscribedSegments = `-- name: GetCountOfUntranscribedSegments :one
SELECT COUNT(*)
FROM
    conversations AS c
    JOIN convert AS conv ON c.id = conv.conversations_id
    JOIN diarize AS d ON conv.id = d.convert_id
    JOIN segments AS s ON d.id = s.diarize_id
    JOIN transcriptions AS t ON s.id = t.segment_id
WHERE
    c.id = $1
    AND t.transcription IS NULL
`

func (q *Queries) GetCountOfUntranscribedSegments(ctx context.Context, id uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getCountOfUntranscribedSegments, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getFullTranscriptionByConversationID = `-- name: GetFullTranscriptionByConversationID :many
SELECT
    conv.audio_len,
    cs.speaker,
    p.name AS participant_name,
    t.transcription
FROM conversations AS c
JOIN convert AS conv ON c.id = conv.conversations_id
JOIN diarize AS d ON conv.id = d.convert_id
JOIN segments AS s ON d.id = s.diarize_id
JOIN transcriptions AS t ON s.id = t.segment_id
JOIN conversation_speakers AS cs ON s.speaker_id = cs.id
LEFT JOIN participants AS p ON cs.participant_id = p.id
WHERE
    c.id = $1
ORDER BY s.start_time
`

type GetFullTranscriptionByConversationIDRow struct {
	AudioLen        *float64 `json:"audio_len"`
	Speaker         int32    `json:"speaker"`
	ParticipantName *string  `json:"participant_name"`
	Transcription   *string  `json:"transcription"`
}

func (q *Queries) GetFullTranscriptionByConversationID(ctx context.Context, id uuid.UUID) ([]GetFullTranscriptionByConversationIDRow, error) {
	rows, err := q.db.Query(ctx, getFullTranscriptionByConversationID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFullTranscriptionByConversationIDRow
	for rows.Next() {
		var i GetFullTranscriptionByConversationIDRow
		if err := rows.Scan(
			&i.AudioLen,
			&i.Speaker,
			&i.ParticipantName,
			&i.Transcription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTranscriptionTextByID = `-- name: UpdateTranscriptionTextByID :exec
UPDATE transcriptions SET transcription = $1 WHERE id = $2
`

type UpdateTranscriptionTextByIDParams struct {
	Transcription *string   `json:"transcription"`
	ID            uuid.UUID `json:"id"`
}

func (q *Queries) UpdateTranscriptionTextByID(ctx context.Context, arg UpdateTranscriptionTextByIDParams) error {
	_, err := q.db.Exec(ctx, updateTranscriptionTextByID, arg.Transcription, arg.ID)
	return err
}

const updateTranscriptionTextBySegmentID = `-- name: UpdateTranscriptionTextBySegmentID :exec
UPDATE transcriptions 
SET transcription = $1 
WHERE segment_id = $2
`

type UpdateTranscriptionTextBySegmentIDParams struct {
	Transcription *string   `json:"transcription"`
	SegmentID     uuid.UUID `json:"segment_id"`
}

func (q *Queries) UpdateTranscriptionTextBySegmentID(ctx context.Context, arg UpdateTranscriptionTextBySegmentIDParams) error {
	_, err := q.db.Exec(ctx, updateTranscriptionTextBySegmentID, arg.Transcription, arg.SegmentID)
	return err
}

const updateTranscriptionTextByTaskID = `-- name: UpdateTranscriptionTextByTaskID :exec
UPDATE transcriptions SET transcription = $1 WHERE task_id = $2
`

type UpdateTranscriptionTextByTaskIDParams struct {
	Transcription *string   `json:"transcription"`
	TaskID        uuid.UUID `json:"task_id"`
}

func (q *Queries) UpdateTranscriptionTextByTaskID(ctx context.Context, arg UpdateTranscriptionTextByTaskIDParams) error {
	_, err := q.db.Exec(ctx, updateTranscriptionTextByTaskID, arg.Transcription, arg.TaskID)
	return err
}
